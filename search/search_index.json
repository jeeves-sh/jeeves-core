{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Welcome to jeeves!"},{"location":"decisions/","text":"","title":"Index"},{"location":"decisions/convert-to-subtask/","text":"Context I need to convert a task (or a story) to a subtask. Decision Unfortunately, that is impossible: not with REST API at least and not using Automation . Consequences Suffering :(","title":"Convert a Jira task to a subtask"},{"location":"decisions/convert-to-subtask/#context","text":"I need to convert a task (or a story) to a subtask.","title":"Context"},{"location":"decisions/convert-to-subtask/#decision","text":"Unfortunately, that is impossible: not with REST API at least and not using Automation .","title":"Decision"},{"location":"decisions/convert-to-subtask/#consequences","text":"Suffering :(","title":"Consequences"},{"location":"decisions/dependency-injection/","text":"Context Why does jeeves need a DI framework? jeeves aims to be a Pythonic alternative to GNU Make. GNU Make enjoys an ad-hoc dependency framework, which permits to only execute a task if certain file is up to date, or to execute a dependent task only after running the task it depends on. That's what jeeves has to do either. For example, jeeves move command, which will operate on currently selected task, must first ensure that Jira (or another task management) system connection has been established. Only then we can do any task manipulation. What do we currently use? At the moment of writing, we're using \ud83d\udd17 dependencies library but I have certain reservations about it. Comparison Tool Requires Classes? Passing config params Notes \ud83d\udd17 dependencies \u2795 \u2714\ufe0f Requires classes \ud83d\udd17 Typer \ud83d\udd17 does not exist \ud83d\udd17 inject \u2796 \ud83e\udd14 Info At the moment of writing, inject seems to be an interesting choice to play with. I will try it. Document is to be continued... Decision ... Consequences ...","title":"Choosing dependency injection framework"},{"location":"decisions/dependency-injection/#context","text":"","title":"Context"},{"location":"decisions/dependency-injection/#why-does-jeeves-need-a-di-framework","text":"jeeves aims to be a Pythonic alternative to GNU Make. GNU Make enjoys an ad-hoc dependency framework, which permits to only execute a task if certain file is up to date, or to execute a dependent task only after running the task it depends on. That's what jeeves has to do either. For example, jeeves move command, which will operate on currently selected task, must first ensure that Jira (or another task management) system connection has been established. Only then we can do any task manipulation.","title":"Why does jeeves need a DI framework?"},{"location":"decisions/dependency-injection/#what-do-we-currently-use","text":"At the moment of writing, we're using \ud83d\udd17 dependencies library but I have certain reservations about it.","title":"What do we currently use?"},{"location":"decisions/dependency-injection/#comparison","text":"Tool Requires Classes? Passing config params Notes \ud83d\udd17 dependencies \u2795 \u2714\ufe0f Requires classes \ud83d\udd17 Typer \ud83d\udd17 does not exist \ud83d\udd17 inject \u2796 \ud83e\udd14 Info At the moment of writing, inject seems to be an interesting choice to play with. I will try it. Document is to be continued...","title":"Comparison"},{"location":"decisions/dependency-injection/#decision","text":"... Consequences ...","title":"Decision"},{"location":"decisions/move/","text":"Context I need to move issues from one project to another. Decision Unfortunately, that is impossible: not with automation and not from API . Consequences Suffering :)","title":"Move a Jira issue to another project"},{"location":"decisions/move/#context","text":"I need to move issues from one project to another.","title":"Context"},{"location":"decisions/move/#decision","text":"Unfortunately, that is impossible: not with automation and not from API .","title":"Decision"},{"location":"decisions/move/#consequences","text":"Suffering :)","title":"Consequences"},{"location":"decisions/paver/","text":"Context Paver is a project with goals very similar to mine: it proposes to replace GNU Make with Python functions. I have written a little example in it. from paver.tasks import task , cmdopts @task @cmdopts ([ ( 'key=' , 'k' , 'Key of the task' ) ]) def select ( options ): \"\"\"Select a Jira task to manipulate.\"\"\" print ( options ) Decision Unfortunately, I do not see a way to use Paver. It apparently does not support command line arguments. $ paver select RM3-588 ---> pavement.select Namespace ( dry_run = None, pavement_file = 'pavement.py' , select = Bunch ()) Build failed: Unknown task: RM3-588 When you manage to propagate the command line option into the function, you cannot access it as a function argument. $ paver select -k RM3-588 ---> pavement.select Namespace ( dry_run = None, pavement_file = 'pavement.py' , select = Bunch ( key = 'RM3-588' )) So I have to dive into the Namespace object and then to select member inside it... Seriously? Type annotations are not used to describe options or dependencies. I would think that a principle similar to FastAPI would be very helpful here. In particular: By default, every argument is considered a command line argument; Using a special Depends() object you can declare it as a dependency. And that's it. No additional decorators needed. Consequences paver is great but it must be reworked too heavily, I am afraid, to be useful.","title":"Evaluate Paver"},{"location":"decisions/paver/#context","text":"Paver is a project with goals very similar to mine: it proposes to replace GNU Make with Python functions. I have written a little example in it. from paver.tasks import task , cmdopts @task @cmdopts ([ ( 'key=' , 'k' , 'Key of the task' ) ]) def select ( options ): \"\"\"Select a Jira task to manipulate.\"\"\" print ( options )","title":"Context"},{"location":"decisions/paver/#decision","text":"Unfortunately, I do not see a way to use Paver. It apparently does not support command line arguments. $ paver select RM3-588 ---> pavement.select Namespace ( dry_run = None, pavement_file = 'pavement.py' , select = Bunch ()) Build failed: Unknown task: RM3-588 When you manage to propagate the command line option into the function, you cannot access it as a function argument. $ paver select -k RM3-588 ---> pavement.select Namespace ( dry_run = None, pavement_file = 'pavement.py' , select = Bunch ( key = 'RM3-588' )) So I have to dive into the Namespace object and then to select member inside it... Seriously? Type annotations are not used to describe options or dependencies. I would think that a principle similar to FastAPI would be very helpful here. In particular: By default, every argument is considered a command line argument; Using a special Depends() object you can declare it as a dependency. And that's it. No additional decorators needed.","title":"Decision"},{"location":"decisions/paver/#consequences","text":"paver is great but it must be reworked too heavily, I am afraid, to be useful.","title":"Consequences"},{"location":"decisions/register-command/","text":"Context jeeves is planned to be a tool that is easy to integrate into any existing project. Somehow, creating a new jeeves command must be no harder than writing a new Makefile goal. Suppose we're writing a new project and for it we want to introduce a new command: def acme ( foo : str ): ... and we want to make it available as j acme buzinga . How do we do that? Look for all Python functions in a file with a special name This is very similar to what GNU Make does - just look for jeeves.py in the current directory. We can scan such a file for every callable and register all such callables as Typer commands. Decision After some thought, I came up with a very simple approach. I am defining commands using setuptools entry points: [tool.poetry.plugins.jeeves] create = \"jeeves_jira:create\" clone = \"jeeves_jira:clone\" fork = \"jeeves_jira:fork\" list = \"jeeves_jira:list_issues\" select = \"jeeves_jira:select\" link = \"jeeves_jira:link\" auth = \"jeeves_jira:auth\" update = \"jeeves_jira:update\" roadmap = \"jeeves_jira:roadmap\" heatmap = \"jeeves_jira:heatmap\" status = \"jeeves_jira:status\" comment = \"jeeves_jira:comment\" lint = \"jeeves_jira:lint\" evaluate = \"jeeves_jira:evaluate\" Easily enough, this registers commands:","title":"Register a new command"},{"location":"decisions/register-command/#context","text":"jeeves is planned to be a tool that is easy to integrate into any existing project. Somehow, creating a new jeeves command must be no harder than writing a new Makefile goal. Suppose we're writing a new project and for it we want to introduce a new command: def acme ( foo : str ): ... and we want to make it available as j acme buzinga . How do we do that?","title":"Context"},{"location":"decisions/register-command/#look-for-all-python-functions-in-a-file-with-a-special-name","text":"This is very similar to what GNU Make does - just look for jeeves.py in the current directory. We can scan such a file for every callable and register all such callables as Typer commands.","title":"Look for all Python functions in a file with a special name"},{"location":"decisions/register-command/#decision","text":"After some thought, I came up with a very simple approach. I am defining commands using setuptools entry points: [tool.poetry.plugins.jeeves] create = \"jeeves_jira:create\" clone = \"jeeves_jira:clone\" fork = \"jeeves_jira:fork\" list = \"jeeves_jira:list_issues\" select = \"jeeves_jira:select\" link = \"jeeves_jira:link\" auth = \"jeeves_jira:auth\" update = \"jeeves_jira:update\" roadmap = \"jeeves_jira:roadmap\" heatmap = \"jeeves_jira:heatmap\" status = \"jeeves_jira:status\" comment = \"jeeves_jira:comment\" lint = \"jeeves_jira:lint\" evaluate = \"jeeves_jira:evaluate\" Easily enough, this registers commands:","title":"Decision"},{"location":"decisions/stateless-vs-stateful/","text":"Stateful # Set the task I am working on jeeves task start CBS-123 # Find the task I am working on right now jeeves task current # Split the task jeeves task split [ CBS-123 ] # Create a prerequisite to current task jeeves task create prerequisite --to CBS-123 # Create a task to follow after current task jeeves task create next # Send task to review jeeves task to review # Mark task as done jeeves task to done # What next task to work on from my board or the backlog? jeeves task next jeeves task link CBS-3464 split-to CBS-3467","title":"Use stateful workflow instead of stateless"},{"location":"decisions/stateless-vs-stateful/#stateful","text":"# Set the task I am working on jeeves task start CBS-123 # Find the task I am working on right now jeeves task current # Split the task jeeves task split [ CBS-123 ] # Create a prerequisite to current task jeeves task create prerequisite --to CBS-123 # Create a task to follow after current task jeeves task create next # Send task to review jeeves task to review # Mark task as done jeeves task to done # What next task to work on from my board or the backlog? jeeves task next jeeves task link CBS-3464 split-to CBS-3467","title":"Stateful"},{"location":"decisions/structure/","text":"Context At \u2714\ufe0f ADR002 Choosing dependency injection framework we have been discussing DI frameworks, but that was probably a bit premature. The more appropriate question would perhaps sound like: How should the application be structured overall? Let us discuss a few options. Simplest case If I were writing just a hard-coded tool for my most often used commands, with no concern about reusability, I would certainly use \ud83d\udd17 Typer . How to structure various Typer commands? Something like this might have been appropriate. app.py import typer app = typer . Typer () move.py from jeeves.app import app from jeeves.jira import create_jira @app . command def move ( key : str , project : str ): issue = create_jira () . issue ( key ) ... In the simplest case, I would use Typer command functions as they are, and not use any dependency injection framework at all. Do we even need a DI here? It is, I must confess, a bit annoying to have to constantly call create_jira() in every Jira-related task. I would prefer to just add a jira argument - and expect this argument filled in for me. Something like this in inject : @app . command def move ( key : str , to : str , project : str , jira : None = Depends ( jira )) ... Just like in FastAPI. Unfortunately, Typer, in contrast to FastAPI, does not support such a model. Can we fix that? I tried to fix that using inject but failed. The argument to the function is considered by Typer to be an argument, or an option, which it is trying to interpret for the CLI. Perhaps something akin to functools.partial can help but I presently do not see a way to apply it.","title":"Choose commands structure"},{"location":"decisions/structure/#context","text":"At \u2714\ufe0f ADR002 Choosing dependency injection framework we have been discussing DI frameworks, but that was probably a bit premature. The more appropriate question would perhaps sound like: How should the application be structured overall? Let us discuss a few options.","title":"Context"},{"location":"decisions/structure/#simplest-case","text":"If I were writing just a hard-coded tool for my most often used commands, with no concern about reusability, I would certainly use \ud83d\udd17 Typer . How to structure various Typer commands? Something like this might have been appropriate. app.py import typer app = typer . Typer () move.py from jeeves.app import app from jeeves.jira import create_jira @app . command def move ( key : str , project : str ): issue = create_jira () . issue ( key ) ... In the simplest case, I would use Typer command functions as they are, and not use any dependency injection framework at all.","title":"Simplest case"},{"location":"decisions/structure/#do-we-even-need-a-di-here","text":"It is, I must confess, a bit annoying to have to constantly call create_jira() in every Jira-related task. I would prefer to just add a jira argument - and expect this argument filled in for me. Something like this in inject : @app . command def move ( key : str , to : str , project : str , jira : None = Depends ( jira )) ... Just like in FastAPI. Unfortunately, Typer, in contrast to FastAPI, does not support such a model. Can we fix that? I tried to fix that using inject but failed. The argument to the function is considered by Typer to be an argument, or an option, which it is trying to interpret for the CLI. Perhaps something akin to functools.partial can help but I presently do not see a way to apply it.","title":"Do we even need a DI here?"}]}